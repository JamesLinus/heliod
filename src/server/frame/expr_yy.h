/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * Copyright 2008 Sun Microsystems, Inc. All rights reserved.
 *
 * THE BSD LICENSE
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. 
 * Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution. 
 *
 * Neither the name of the  nor the names of its contributors may be
 * used to endorse or promote products derived from this software without 
 * specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER 
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FRAME_EXPR_YY_H
#define FRAME_EXPR_YY_H

/*
 * expr_yy.h: NSAPI expression yacc parser interface
 * 
 * Chris Elving
 */

#include "netsite.h"
#include "frame/expr.h"
#include "expr.tab.h"

/*
 * YYMAXDEPTH 0 indicates that expr_yy_parse should allocate its value and
 * state stacks using the YYEXPAND macro.
 */
#define YYMAXDEPTH 0

/*
 * YYEXPAND allocates value and state stacks for expr_yy_parse.
 */
#define YYEXPAND(depth) expr_yy_expand(yydata, depth)

/*
 * YYDATA stores context for expr_yy_parse.  It replaces the global variables
 * found in normal (non-reentrant, non-MT-safe) yacc-generated parsers.
 */
typedef struct {
    struct LexerData *lexer;   /* context for expr_yy_lex */
    struct ParserData *parser; /* context for expr_parse */

    int yychar;                /* current input token number */
    YYSTYPE yylval;
    YYSTYPE yyval;

    int yymaxdepth;            /* stack size */
    YYSTYPE *yyv;              /* value stack */
    int *yys;                  /* state stack */

    YYSTYPE *yypv;             /* top of value stack */

    int yystate;               /* current state */
    int *yyps;                 /* top of state stack */

    int yytmp;                 /* extra var (lasts between blocks) */

    int yynerrs;               /* number of errors */
    int yyerrflag;             /* error recovery flag */
} YYDATA;

/*
 * expr_yy_parse is the parser generated by yacc.  Do not invoke expr_yy_parse
 * directly; use expr_parse instead.
 */
int expr_yy_parse(YYDATA *yydata);

/*
 * expr_yy_lex is called by expr_yy_parse to obtain the next token.  Returns an
 * EXPR_TOKEN_* integer constant and sets expr_yy_lval on success.  Returns -1
 * on EOF.
 */
int expr_yy_lex(YYDATA *yydata);

/*
 * expr_yy_expand is called by expr_yy_parse (via YYEXPAND) to allocate value
 * and state stacks.
 */
int expr_yy_expand(YYDATA *yydata, int depth);

/*
 * expr_yy_error is called by expr_yy_parse to report errors.
 */
void expr_yy_error(YYDATA *yydata, const char *msg);

/*
 * expr_yy_expr is called (via an EXPR_YY_* macro) by expr_yy_parse to record
 * the creation of an expression list.
 */
Expression *expr_yy_expr(YYDATA *yydata, Expression *e);

/*
 * expr_yy_args is called (via an EXPR_YY_* macro) by expr_yy_parse to record
 * the creation of an argument list.
 */
Arguments *expr_yy_args(YYDATA *yydata, Arguments *a);

/*
 * The following EXPR_YY_* macros are used by expr_yy_parse to construct an
 * expression tree according to the expression grammar defined by expr.y.
 */
#define EXPR_YY_NAMED_OR(l, r) expr_yy_expr(yydata, expr_new_named_or(l, r))
#define EXPR_YY_NAMED_XOR(l, r) expr_yy_expr(yydata, expr_new_named_xor(l, r))
#define EXPR_YY_NAMED_AND(l, r) expr_yy_expr(yydata, expr_new_named_and(l, r))
#define EXPR_YY_NAMED_NOT(r) expr_yy_expr(yydata, expr_new_named_not(r))
#define EXPR_YY_TERNARY(x, y, z) expr_yy_expr(yydata, expr_new_ternary(x, y, z))
#define EXPR_YY_C_OR(l, r) expr_yy_expr(yydata, expr_new_c_or(l, r))
#define EXPR_YY_C_AND(l, r) expr_yy_expr(yydata, expr_new_c_and(l, r))
#define EXPR_YY_C_XOR(l, r) expr_yy_expr(yydata, expr_new_c_xor(l, r))
#define EXPR_YY_NUMERIC_EQ(l, r) expr_yy_expr(yydata, expr_new_numeric_eq(l, r))
#define EXPR_YY_NUMERIC_NE(l, r) expr_yy_expr(yydata, expr_new_numeric_ne(l, r))
#define EXPR_YY_STRING_EQ(l, r) expr_yy_expr(yydata, expr_new_string_eq(l, r))
#define EXPR_YY_STRING_NE(l, r) expr_yy_expr(yydata, expr_new_string_ne(l, r))
#define EXPR_YY_NUMERIC_LT(l, r) expr_yy_expr(yydata, expr_new_numeric_lt(l, r))
#define EXPR_YY_NUMERIC_LE(l, r) expr_yy_expr(yydata, expr_new_numeric_le(l, r))
#define EXPR_YY_NUMERIC_GT(l, r) expr_yy_expr(yydata, expr_new_numeric_gt(l, r))
#define EXPR_YY_NUMERIC_GE(l, r) expr_yy_expr(yydata, expr_new_numeric_ge(l, r))
#define EXPR_YY_STRING_LT(l, r) expr_yy_expr(yydata, expr_new_string_lt(l, r))
#define EXPR_YY_STRING_LE(l, r) expr_yy_expr(yydata, expr_new_string_le(l, r))
#define EXPR_YY_STRING_GT(l, r) expr_yy_expr(yydata, expr_new_string_gt(l, r))
#define EXPR_YY_STRING_GE(l, r) expr_yy_expr(yydata, expr_new_string_ge(l, r))
#define EXPR_YY_NAMED_OP(l, r) expr_yy_expr(yydata, expr_new_named_op(l, r))
#define EXPR_YY_ADD(l, r) expr_yy_expr(yydata, expr_new_add(l, r))
#define EXPR_YY_SUBTRACT(l, r) expr_yy_expr(yydata, expr_new_subtract(l, r))
#define EXPR_YY_CONCAT(l, r) expr_yy_expr(yydata, expr_new_concat(l, r))
#define EXPR_YY_MULTIPLY(l, r) expr_yy_expr(yydata, expr_new_multiply(l, r))
#define EXPR_YY_DIVIDE(l, r) expr_yy_expr(yydata, expr_new_divide(l, r))
#define EXPR_YY_MODULO(l, r) expr_yy_expr(yydata, expr_new_modulo(l, r))
#define EXPR_YY_WILDCARD(l, r) expr_yy_expr(yydata, expr_new_wildcard(l, r))
#define EXPR_YY_RE(l, r, m) expr_yy_expr(yydata, expr_new_re(l, r, m))
#define EXPR_YY_C_NOT(r) expr_yy_expr(yydata, expr_new_c_not(r))
#define EXPR_YY_POSITIVE(r) expr_yy_expr(yydata, expr_new_positive(r))
#define EXPR_YY_NEGATIVE(r) expr_yy_expr(yydata, expr_new_negative(r))
#define EXPR_YY_CALL(f, a) expr_yy_expr(yydata, expr_new_call(f, a))
#define EXPR_YY_ACCESS(i, s) expr_yy_expr(yydata, expr_new_access(i, s))
#define EXPR_YY_VARIABLE(i) expr_yy_expr(yydata, expr_new_variable(i))
#define EXPR_YY_IDENTIFIER(i) expr_yy_expr(yydata, expr_new_identifier(i))
#define EXPR_YY_TRUE() expr_yy_expr(yydata, expr_new_true())
#define EXPR_YY_FALSE() expr_yy_expr(yydata, expr_new_false())
#define EXPR_YY_NUMBER(n) expr_yy_expr(yydata, expr_new_number(n))
#define EXPR_YY_STRING(s) expr_yy_expr(yydata, expr_new_string(s))
#define EXPR_YY_INTERPOLATIVE(s) expr_yy_expr(yydata, expr_new_interpolative(s))
#define EXPR_YY_ARGS_EMPTY() expr_yy_args(yydata, args_create())
#define EXPR_YY_ARGS_CREATE(e) expr_yy_args(yydata, args_append(NULL, e))
#define EXPR_YY_ARGS_APPEND(a, e) args_append(a, e)

#endif // FRAME_EXPR_YY_H
